# npx Tool Architecture — Conceptual Plan

## Executive Summary

This document outlines the architecture for transforming Oyinbo from a repository-local development tool into a globally invocable CLI tool that can be run from any directory. The goal is to enable `npx oyinbo` (or similar command) to start the REPL-enabled HTTP server for any project, with sensible defaults and optional parameters.

**Key Insight**: The core modules (`registry.js`, `server.js`, `watcher.js`, `job.js`, etc.) are already parameterized by `root` directory. The architecture is fundamentally ready for multi-directory operation. The challenge is purely about CLI ergonomics, package distribution, and sensible defaults.

---

## Current State Analysis

### What Works Today

The standalone server runs in the Oyinbo repository:
- Hardcoded `ROOT = join(__dirname, '..')` resolves to Oyinbo repo root
- Hardcoded `PORT = 8302` (or from `process.env.PORT`)
- Expects `debug/` directory and `debug.md` file relative to ROOT
- Serves files from ROOT as static content
- All core modules accept `root` as parameter and operate relative to it

### What Needs to Change

1. **ROOT resolution**: Instead of package directory, use invocation directory
2. **Port selection**: Instead of hardcoded 8302, derive from directory name hash
3. **Package structure**: Enable global npm installation and `npx` execution
4. **CLI argument parsing**: Accept optional parameters for root and port
5. **User experience**: Clear startup message, helpful error messages

### What Remains Unchanged

All core logic is already parameterized and reusable:
- `registry.init(root)`, `registry.getOrCreate(root, name, url)`, `registry.updateMaster(root)`
- `server.start(root, port)` — serves files from `root`, injects client script
- `watcher.watchPage(root, page)`, `watcher.watchForRestart(root)`
- `job.js`, `parser.js`, `writer.js` — operate on file paths derived from registry

No module rewrites needed. Pure CLI and packaging changes.

---

## Functional Requirements

### Core Use Cases

**UC1: Default invocation from any directory**
```
cd /some/project
npx oyinbo
```
Expected behavior:
- Root directory = `/some/project` (current working directory)
- Port = derived from hash of "some-project" (e.g., 8345)
- Server starts, watches `debug/`, serves files from project root
- Console logs: `[oyinbo] serving /some/project on http://localhost:8345/`

**UC2: Explicit root directory**
```
npx oyinbo --root=/path/to/other/project
```
Expected behavior:
- Root directory = `/path/to/other/project`
- Port = derived from hash of "other-project"
- Serves from specified root

**UC3: Explicit port**
```
npx oyinbo --port=9000
```
Expected behavior:
- Root directory = current directory
- Port = 9000 (user override)

**UC4: Both parameters**
```
npx oyinbo --root=/path/to/project --port=9000
```

**UC5: Help and version**
```
npx oyinbo --help
npx oyinbo --version
```

### Port Derivation Algorithm

**Goal**: Consistent, deterministic port based on project directory name, avoiding common port conflicts.

**Algorithm**:
1. Extract directory name from root path (e.g., `/foo/bar/my-project` → `my-project`)
2. Compute hash of directory name (simple string hash, not cryptographic)
3. Map hash to port range: 8100–9099 (1000 ports)
4. Formula: `8100 + (hash(name.toLowerCase()) % 1000)`

**Rationale**:
- Same project → same port (predictable)
- Different projects → likely different ports (reduces conflicts)
- Range 8300-8399 unlikely to conflict with common services
- 100 ports = reasonable collision space for typical dev machine

**Edge Case**: Port already in use
- Attempt to bind port
- On EADDRINUSE error, compute fallback ports by varying the hash input and retrying: for i = 1..19 compute `8100 + (hash((dirname + i).toLowerCase()) % 1000)` and try each resulting port in sequence. If a port is free, bind it and continue. If all 20 computed ports (initial + 19 retries) are taken, fail with an error message: "Could not find available port. Specify --port explicitly."

**Example Hashing** (conceptual):
```
"my-project"  → hash(lowercase) → 42 → 8100 + 42 = 8142
"other-repo"  → hash(lowercase) → 7  → 8100 + 7  = 8107
"foo"         → hash(lowercase) → 89 → 8100 + 89 = 8189
```

If the chosen port is taken, the fallback sequence will try variants such as:
```
8100 + (hash('my-project1') % 1000),
8100 + (hash('my-project2') % 1000),
... up to 19 retries
```

---

## Architecture Overview

### Package Structure

**Conceptual Layout**:
```
oyinbo/
  package.json          (main → js/cli.js, bin → index.js)
  index.js              (shebang + minimal runner: calls run() from js/cli.js)
  js/
    cli.js              (CLI parsing, root/port resolution, server startup)
    server.js           (unchanged)
    registry.js         (unchanged)
    ... all other core modules (unchanged)
  docs/                 (unchanged)
  debug/                (example, not distributed)
```

**Key Changes**:
- `package.json` `bin` field points to `index.js` (for `npx oyinbo` executable)
- `package.json` `main` field points to `js/cli.js` (package entry; may change later)
- `index.js` stays minimal: shebang + `import { run } from './js/cli.js'` + `run()`
- `js/cli.js` (existing file): contains all CLI argument parsing, root/port resolution, and server startup logic
- No `bin/` directory needed; npm creates executable wrapper automatically from `bin` field

### Entry Points

**For npx/global install** (`npx oyinbo`):
- npm uses `package.json` `bin` field, runs `index.js`
- npm automatically creates executable wrapper with shebang

**For local/development run** (`npm start` or `node index.js`):
- Runs `index.js` directly
- Same file as npx entry, minimal overhead

**Main logic** (`js/cli.js`):
- Parse CLI arguments from `process.argv`
- Resolve root (default: `process.cwd()`)
- Resolve port (default: hash-based derivation)
- Handle `--root`, `--port`, `--help`, `--version` flags
- Validate inputs and display helpful errors
- Initialize registry and start server
- Exported as `export function run() { ... }` for import by `index.js`

---

## CLI Design

### Argument Parsing

**Philosophy**: Minimal dependencies, use Node.js built-ins if possible. Avoid heavy CLI frameworks unless necessary.

**Approach**: Use `process.argv` parsing with simple logic:
- `--root=<path>` or `--root <path>`
- `--port=<number>` or `--port <number>`
- `--help`, `-h`
- `--version`, `-v`

**Implementation Strategy**:
- No external library initially (pure `process.argv` slicing)
- If complexity grows, consider lightweight parser (e.g., `minimist`, 2KB)
- Validation: ensure root exists, ensure port is numeric 1–65535

### Help Text

**Conceptual Format**:
```
oyinbo — File-based REPL for JavaScript

Usage:
  npx oyinbo [options]

Options:
  --root <path>     Project root directory (default: current directory)
  --port <number>   HTTP server port (default: derived from project name)
  --help, -h        Show this help
  --version, -v     Show version

Examples:
  npx oyinbo
  npx oyinbo --port=9000
  npx oyinbo --root=/path/to/project

Documentation: https://github.com/oyin-bo/oyinbo
```

### Startup Message

**Conceptual Format**:
```
[oyinbo] serving /Users/alice/my-project
[oyinbo] http://localhost:8342/
[oyinbo] debug registry: debug.md
[oyinbo] watching: debug/*.md

  index.html connected for debug/index-html.md
```

**Requirements**:
- Show resolved root and port
- Show full URL for easy copying
- Indicate where debug files live
- Log each page connection (already implemented)

### Error Handling

**Scenario**: Root directory doesn't exist
```
[oyinbo] error: root directory does not exist: /foo/bar
Use --root to specify a valid directory.
```

**Scenario**: Port unavailable after retries
```
[oyinbo] error: could not bind to port 8342 or nearby ports
Try --port=<number> to specify a different port.
```

**Scenario**: Invalid argument
```
[oyinbo] error: unknown option: --foo
Run 'npx oyinbo --help' for usage.
```

---

## Package Distribution

### package.json Configuration

**Key Fields**:

**`bin` field** (creates executable):
```json
{
  "bin": {
    "oyinbo": "./index.js"
  }
}
```
This makes `npx oyinbo` invoke `index.js` (npm creates the executable wrapper automatically with shebang). Used for both global install and local `npm start`.

**`main` field** (package entry point):
```json
{
  "main": "./js/cli.js"
}
```
The main package entry; used when the package is imported. Currently points to `js/cli.js` (may change later). Points to the file that contains all CLI argument parsing and server startup logic.

**`type` field** (already set):
```json
{
  "type": "module"
}
```
Enables ES modules (unchanged).

**`files` field** (what gets published):
```json
{
  "files": [
    "bin/",
    "js/",
    "index.js",
    "README.md",
    "LICENSE"
  ]
}
```
Excludes `debug/`, `docs/`, test files.

**`engines` field** (Node version requirement):
```json
{
  "engines": {
    "node": ">=18.0.0"
  }
}
```
Node 18+ for native `node:test` and stable import maps support.

### npm Publishing Workflow

**Checklist**:
1. Update version in `package.json`
2. Test locally with `npm link` (simulates global install)
3. Test with `npx .` in another directory
4. Publish: `npm publish`
5. Test globally: `npx oyinbo@latest` from fresh directory

### Versioning Strategy

**Semantic Versioning**:
- Patch: bug fixes, documentation
- Minor: new CLI options, backward-compatible features
- Major: breaking changes (e.g., new required config)

Current version in package.json: `0.0.9` → suggests pre-1.0 phase.

**Recommendation for npx release**: Bump to `1.0.0` to signal stability and production-readiness.

---

## Implementation Roadmap

### Phase 1: CLI Infrastructure

**Goal**: Make `npx oyinbo` runnable from any directory with default behavior.

**Tasks**:
1. Refactor `js/cli.js`: extract argument parsing, implement root/port resolution (default: `process.cwd()` + hash-based)
2. Update `index.js` minimal stub: shebang + `import { run } from './js/cli.js'` + `run()`
3. Update `package.json`: set `main` to `js/cli.js`, add `bin` field pointing to `index.js`
4. Test with `npm start` from repo root and `npm link` from other directories

**Success Criteria**:
- `npm start` from repo root works (`node index.js` runs server in repo)
- `npx oyinbo` from another directory starts server in that directory
- Port is deterministic based on directory name
- Startup message shows resolved root and port
- Ctrl+C cleanly shuts down server

### Phase 2: Parameter Overrides

**Goal**: Support `--root` and `--port` CLI options in `js/cli.js`.

**Tasks**:
1. Parse `--root` and validate directory exists
2. Parse `--port` and validate numeric range
3. Override defaults with user-provided values
4. Add error messages for invalid inputs
5. Test with various combinations of flags

**Success Criteria**:
- `npx oyinbo --root=/foo` uses specified directory
- `npx oyinbo --port=9000` uses specified port
- Invalid inputs show helpful error messages
- Both flags are parsed and handled in `js/cli.js`

### Phase 3: Port Collision Handling

**Goal**: Gracefully handle port conflicts in `js/cli.js` when starting the server.

**Tasks**:
1. Wrap `server.listen()` in try-catch for EADDRINUSE
2. Implement retry logic (hash variation, max 20 attempts per spec)
3. Log each retry attempt
4. Final error if all ports unavailable

**Success Criteria**:
- If derived port in use, tries fallback ports via hash variation
- Logs: `[oyinbo] port 8342 in use, trying 8343...`
- Final message shows actual bound port
- Retry logic implemented in `js/cli.js` before starting server

### Phase 4: Documentation and Publishing

**Goal**: Publish to npm and document usage.

**Tasks**:
1. Update README with npx usage examples
2. Add CONTRIBUTING guide for local development
3. Test with `npm pack` and install from tarball
4. Publish to npm registry
5. Verify `npx oyinbo@latest` works globally

**Success Criteria**:
- Package is discoverable on npmjs.com
- `npx oyinbo` works without prior install
- README shows clear usage examples

---

## Design Decisions and Trade-offs

### Decision 1: Root Directory Default

**Options**:
- A: Current working directory (`process.cwd()`)
- B: User home directory (`os.homedir()`)
- C: Require explicit `--root` flag (no default)

**Choice**: A (current working directory)

**Rationale**:
- Most intuitive: "run tool in this project"
- Matches behavior of other dev tools (webpack-dev-server, vite, etc.)
- User can always override with `--root`

**Trade-off**: User must `cd` to project first (acceptable convention).

### Decision 2: Port Derivation vs. Fixed Default

**Options**:
- A: Fixed port (e.g., 8302 for all projects)
- B: Random available port (find-free-port)
- C: Derived from project name (hash-based)

**Choice**: C (hash-based derivation)

**Rationale**:
- Predictable per-project (same URL every time for same project)
- Avoids conflicts when working on multiple projects simultaneously
- No need to remember/lookup port for each project

**Trade-off**: Potential collisions (mitigated by retry logic).

### Decision 3: CLI Argument Style

**Options**:
- A: GNU-style (`--root=/path`)
- B: Positional (`oyinbo /path 9000`)
- C: Environment variables (`OYINBO_ROOT=/path npx oyinbo`)

**Choice**: A (GNU-style flags)

**Rationale**:
- Self-documenting (`--root` is clearer than positional)
- Allows optional parameters in any order
- Standard for modern CLI tools

**Trade-off**: Slightly more typing (acceptable for clarity).

### Decision 4: Dependency Footprint

**Options**:
- A: Zero dependencies (pure Node.js)
- B: Minimal dependencies (e.g., `minimist` for args)
- C: Full CLI framework (e.g., `commander`, `yargs`)

**Choice**: Start with A, migrate to B if complexity grows

**Rationale**:
- Keep package size small for fast `npx` downloads
- Avoid supply chain risks from large dependency trees
- Simple argument parsing is ~20 lines of code

**Trade-off**: More manual validation logic (acceptable given simplicity).

### Decision 5: Debug Directory Creation

**Options**:
- A: Auto-create `debug/` directory if missing
- B: Require user to create `debug/` manually
- C: Configurable via `--debug-dir` flag

**Choice**: A (auto-create)

**Rationale**:
- Better UX: tool "just works" out of the box
- No downside: directory is lightweight and expected
- Matches behavior of `registry.init()` which already creates `debug.md`

**Trade-off**: None significant (empty directory is harmless).

---

## User Experience Scenarios

### Scenario 1: First-time User

**Context**: Developer hears about Oyinbo, wants to try it on their existing project.

**Flow**:
1. `cd ~/projects/my-app`
2. `npx oyinbo`
3. Server starts, shows `http://localhost:8347/`
4. User opens URL, sees their `index.html`
5. User checks terminal, sees instructions to create `debug/*.md` files
6. User creates `debug/experiment.md`, writes code block
7. Page executes code, result appears in file

**Key UX Elements**:
- No configuration required
- Clear startup message with URL
- Helpful hints about creating debug files
- Immediate feedback when file is detected

### Scenario 2: Multi-project Developer

**Context**: Developer works on 3 projects simultaneously, wants REPL for all.

**Flow**:
1. Terminal 1: `cd ~/proj1 && npx oyinbo` → port 8312
2. Terminal 2: `cd ~/proj2 && npx oyinbo` → port 8345
3. Terminal 3: `cd ~/proj3 && npx oyinbo` → port 8378
4. All run concurrently, no port conflicts

**Key UX Elements**:
- Deterministic ports: same project → same port tomorrow
- Easy to remember: "proj1 is always 8312"
- No manual port management needed

### Scenario 3: CI/CD Integration

**Context**: Automated tests want to start Oyinbo server programmatically.

**Flow** (conceptual):
```javascript
import { start, init } from 'oyinbo';

init('/path/to/project');
start('/path/to/project', 8400);
// ... run tests
// ... shutdown (future: expose cleanup API)
```

**Key UX Elements**:
- Programmatic API available
- Port can be explicitly controlled for test stability
- No global state pollution

### Scenario 4: Error Recovery

**Context**: User runs `npx oyinbo` but something goes wrong.

**Flow 1: Directory doesn't exist**:
```
npx oyinbo --root=/nonexistent
> [oyinbo] error: root directory does not exist: /nonexistent
```

**Flow 2: Port unavailable**:
```
npx oyinbo --port=8000
> [oyinbo] port 8000 in use, trying 8001...
> [oyinbo] serving /Users/alice/my-project on http://localhost:8001/
```

**Flow 3: No HTML files in project**:
```
npx oyinbo
> [oyinbo] serving /Users/alice/my-project on http://localhost:8342/
> [oyinbo] note: no .html files found in root. Create index.html to get started.
```

**Key UX Elements**:
- Clear, actionable error messages
- Automatic recovery where possible (port retry)
- Helpful hints for common issues

---

## Testing Strategy

### Unit Tests

**What to Test**:
- Port derivation function (deterministic hashing)
- Argument parsing (various flag combinations)
- Root path resolution (relative vs absolute)
- Validation logic (directory exists, port in range)

**Approach**:
- Pure functions extracted from CLI logic
- Test with synthetic inputs (no actual server startup)
- Fast, parallelizable

### Integration Tests

**What to Test**:
- Full CLI invocation from different directories
- Server starts and binds to correct port
- `debug.md` created in correct location
- File serving works from custom root
- Shutdown via `%%SHUTDOWN%%` marker

**Approach**:
- Spawn `node bin/cli.js` as child process
- Use temporary directories for isolation
- HTTP requests to verify server response
- Clean up processes and files after tests

### Manual Testing Checklist

**Pre-publish Validation**:
1. `npm link` in Oyinbo repo
2. `cd /tmp/test-project && npx oyinbo` (verify works from unrelated directory)
3. Test `--root` and `--port` flags
4. Test port collision (start two instances, verify retry)
5. Test `--help` and `--version`
6. Test on Windows and Unix (path separator handling)
7. Test with Node 18, 20, 22 (engine compatibility)

---

## Future Enhancements (Out of Scope)

### Configuration File

**Vision**: Support `.oyinborc` or `oyinbo.config.js` for persistent settings.

**Use Cases**:
- Custom port per project
- Custom debug directory name
- Exclude patterns for file serving
- CSP configuration for worker injection

**Challenges**:
- Config discovery (traverse up directory tree?)
- Format choice (JSON, JS, YAML?)
- Validation and error handling
- Adds complexity to "simple tool" philosophy

**Recommendation**: Defer until user demand is clear. CLI flags sufficient for now.

### Watch Mode for Server Restart

**Vision**: Auto-restart server when `package.json` or config changes.

**Current Behavior**: Server runs until Ctrl+C or `%%SHUTDOWN%%`.

**Enhanced Behavior**: Detect config changes, restart server automatically.

**Challenges**:
- What files to watch? (package.json, .oyinborc, ?)
- How to preserve state? (registry, active jobs)
- Race conditions during restart

**Recommendation**: Nice-to-have, not critical for v1.

### Multi-root Support

**Vision**: One server instance serves multiple project roots.

**Use Case**: Monorepo with multiple packages, single debug registry.

**Challenges**:
- How to specify multiple roots? (`--root=a,b,c`? Config file?)
- Path resolution conflicts (overlapping files)
- URL routing (how to distinguish `a/index.html` vs `b/index.html`?)

**Recommendation**: Complex, low priority. Users can run multiple instances.

### HTTPS Support

**Vision**: Serve over HTTPS for testing service workers, WebRTC, etc.

**Challenges**:
- Certificate generation (self-signed? Let's Encrypt? mkcert?)
- Trust issues (browser warnings)
- Complexity for "simple tool"

**Recommendation**: Out of scope. Users needing HTTPS can proxy via nginx/Caddy.

---

## Security Considerations

### File Serving Boundaries

**Risk**: Serving files outside intended project root.

**Mitigation** (already implemented):
- `server.js` uses `join(root, path)` which normalizes paths
- Node.js `path.join()` prevents `..` traversal escaping
- 404 on `!existsSync(file)` check

**Additional Validation** (consider):
- Explicitly reject paths containing `..` segments
- Log warning if suspicious path requested
- Configurable allowlist/denylist (future)

### Port Binding Scope

**Risk**: Binding to `0.0.0.0` exposes to local network.

**Current Behavior**: `server.listen(port)` defaults to `0.0.0.0`.

**Recommendation**: Consider binding to `127.0.0.1` (localhost-only) by default.

**Trade-off**: Blocks legitimate use case (testing from mobile device). Make configurable?

### Code Execution Sandboxing

**Risk**: Arbitrary code execution in connected pages.

**Current Mitigation**: Code executes in page's existing JavaScript context (same as DevTools Console).

**Not a New Risk**: REPL doesn't add execution capability beyond what page already has. Agent (LLM or human) must be trusted.

**Recommendation**: Document in README that Oyinbo is a debugging tool, not a security boundary.

---

## Compatibility Matrix

### Node.js Versions

**Minimum**: 18.0.0 (for stable `node:test` and import maps)

**Tested**: 18.x, 20.x, 22.x

**Expectation**: Works on all current LTS and later.

### Operating Systems

**Primary**: macOS, Linux (Unix path separators)

**Secondary**: Windows (backslash path separators)

**Considerations**:
- `path.join()` and `path.relative()` handle OS differences
- Console output (ANSI colors?) may differ
- Test on Windows CI to catch path bugs

### Package Managers

**npm**: Primary, official support

**yarn**: Should work (uses npm registry)

**pnpm**: Should work (uses npm registry)

**Recommendation**: Test `pnpm dlx oyinbo` and `yarn dlx oyinbo` before 1.0 release.

---

## Migration Path

### From Current Workflow to npx Tool

**User Perspective**:
- **Before**: Clone Oyinbo repo, `npm start` from within repo
- **After**: `npx oyinbo` from any project directory

**Migration Steps**:
1. Announce npx tool availability
2. Update README with npx instructions
3. Keep `npm start` working in repo (for contributors)
4. Eventually deprecate `npm start` in favor of `npx .` for local testing

**Backward Compatibility**:
- Existing users cloning repo: `npm start` still works (unchanged)
- New users: `npx oyinbo` preferred (no clone needed)
- Contributors: `npm link` for local development

**Breaking Changes**: None. Both workflows coexist.

---

## Open Questions and Decisions Deferred

These are intentionally left unresolved, to be addressed during implementation or user feedback:

1. **CLI argument format**: `--root=/path` vs `--root /path` (space-separated)?
   - Both could be supported with small parser tweak
   - Test empirically with user feedback

2. **Port retry behavior**: Increment by 1 or try random ports?
   - Current plan: increment (predictable)
   - Alternative: random selection from range (fewer collisions?)

3. **Debug directory auto-creation**: Create empty `debug/` or not?
   - Current plan: yes (better UX)
   - Alternative: skip if not needed (cleaner filesystem)

4. **Localhost-only binding**: `0.0.0.0` vs `127.0.0.1`?
   - Security vs flexibility trade-off
   - Consider making configurable in future

5. **Error verbosity**: Detailed stack traces or user-friendly messages?
   - Current plan: user-friendly by default
   - Could add `--verbose` flag for debugging

6. **Package naming**: `oyinbo`, `daeb.ug`, or something else?
   - Current package.json: `daeb.ug`
   - Consider aliasing or renaming for clarity

---

## Conclusion

Transforming Oyinbo into a global npx tool is **architecturally straightforward**: the core is already parameterized for multi-directory use. The work centers on CLI ergonomics, sensible defaults, and package distribution.

**Key Insights**:

1. **Root parameterization exists**: All modules accept `root`, no refactoring needed
2. **Port derivation strategy**: Hash-based for predictability, retry logic for conflicts
3. **CLI simplicity**: Minimal dependencies, clear help text, graceful errors
4. **Package structure**: `bin` field for executable, `main` for programmatic import
5. **Testing pyramid**: Unit tests for pure functions, integration tests for end-to-end

**Next Steps** (for implementation phase):

1. Create `bin/cli.js` with argument parsing and root/port resolution
2. Implement port derivation and collision handling
3. Update `package.json` with `bin`, `files`, and `engines` fields
4. Test with `npm link` from various directories
5. Write integration tests for CLI invocation
6. Update README with npx usage examples
7. Publish to npm registry as v1.0.0

**Design Philosophy Summary**:

This plan is intentionally **conceptual and architectural**. It defines functional requirements, user experience goals, and implementation direction without prescribing exact code. The goal is to establish the **mental model** and **ergonomic principles** that guide development, allowing implementation details to emerge naturally during coding.
