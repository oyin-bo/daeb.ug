# Web Workers & Remote Test Runner — Expanding REPL Capabilities

## Broad Goal and Importance

The Oyinbo REPL currently provides powerful stateful remote execution in browser contexts, enabling AI agents to interact with live web pages. However, **real-world web applications impose constraints that limit debugging effectiveness**: main-thread blocking operations, page script interference, and security policies that prevent certain introspections. Additionally, **agents need the ability to validate code through automated testing**, not just one-off REPL evaluations.

These two features address critical gaps:

1. **Web Worker Realms** provide isolated, parallel execution contexts that remain responsive even when the main page is blocked or compromised
2. **Remote Test Runner** enables systematic validation through unit tests, transforming the REPL from an exploration tool into a comprehensive quality assurance platform

Together, they empower agents to **debug more complex scenarios, validate fixes systematically, and maintain code quality** — essential for autonomous software enhancement at scale.

---

## Auto-Created Web Worker Realms

### Purpose and Agent Benefits

Web worker realms run JavaScript in separate threads, isolated from the main page DOM and event loop. By automatically spawning these invisible worker realms alongside each page, agents gain:

- **Non-blocking execution**: Long-running computations or infinite loops won't freeze the REPL or page
- **Isolation from page interference**: Page scripts, content security policies, or monkey-patched globals won't corrupt REPL state
- **Parallel experimentation**: Test potentially destructive code without risking the main page context
- **Resilience**: Automatic restart and health monitoring ensure worker availability even after crashes

### User Control

- Worker realms appear in the master registry as separate entities (e.g., `7-zen-1201-03-webworker`)
- Agents can target commands to either the main page or its worker by name
- Workers are best-effort: if creation fails (CSP violations, browser limitations), the system gracefully continues with main thread only

---

## Remote Test Runner API

### Purpose and Agent Benefits

While REPL is excellent for exploration, **systematic validation requires running structured test suites**. The remote test runner provides:

- **Standard test primitives**: Node.js-compatible `test`, `describe`, `it`, assertions injected into realm globals
- **Automated test execution**: Import test files and run them remotely, receiving structured results
- **Quality gates**: Agents can validate fixes by running existing test suites against live application state
- **Compatibility**: Matching Node.js test runner API shape allows agents to use familiar patterns

### User Control

- Test runner is exposed as a global function in each realm (main page and workers)
- Agents trigger test runs via REPL commands (e.g., `runTests('./my-test.js')`)
- Results include pass/fail counts, individual test outcomes, timing, and error details
- Test runs don't interfere with REPL state (isolated module contexts)

---

## Technical Architecture: Web Worker Realms

### Initialization Flow

1. **Worker Creation**:
   - When browser client script initializes, attempt to create a web worker
   - Options include inline blob URLs, separate worker script files, or module workers
   - Consider reusing the same injection approach used for page-level REPL code
   - Worker name = `${mainPageName}-webworker` (e.g., `7-zen-1201-03-webworker`)
   - Creation wrapped in try-catch; failures logged but don't break main thread

2. **Worker Registration**:
   - Worker communicates with server identifying itself with its worker name
   - Registration parameters (name, URL/context) can be passed via headers, query params, or request body
   - Server treats worker as separate realm with its own chat log file in `debug/` directory
   - Master `debug.md` lists both page and worker as distinct entries

3. **Bidirectional Communication**:
   - Worker → Server: standard fetch polling loop (identical to main thread)
   - Main Thread → Worker: messaging for health checks and termination commands
   - Server has no direct worker reference; all control flows through main thread

### Heartbeat and Health Monitoring

**Goal**: Detect unresponsive workers and restart them automatically to maintain REPL availability.

**Main Thread Monitoring**:

- Periodically check worker responsiveness through message exchange
- Track missed responses to identify hung or crashed workers
- Balance frequent checks against unnecessary overhead

**Termination and Restart**:

- Terminate unresponsive workers and immediately attempt restart
- Send timeout/restart event to server for diagnostic logging
- Server writes diagnostic message to worker's chat log
- New worker reuses same name suffix and continues using existing chat log
- Consider restart throttling to avoid infinite restart loops

### Caveats and Constraints

**Browser Limitations**:
- CSP headers may block inline worker creation (`worker-src` directive)
- Some browsers don't support blob URLs for workers in certain contexts
- Workers have no DOM access (expected, but limits some debugging scenarios)

**Resource Management**:
- Workers consume memory/CPU; limit to 1 worker per page initially
- Consider future: worker pool for heavy parallelism

**Scope Differences**:
- Worker global is `self`, not `window`
- No access to `document`, `localStorage`, many Web APIs
- Code evaluated in worker must be worker-compatible

**Error Handling**:
- Worker creation failure is silent (logged to console, not REPL)
- Worker crashes without graceful shutdown require heartbeat detection
- Unhandled errors in worker should still post results back (same error capture as main thread)

### Implementation Touch Points

**Implementation Considerations**:

- Client script needs worker creation, health monitoring, and restart logic
- Server needs to handle worker lifecycle events (timeout/restart notifications)
- Writer component should support system-generated diagnostic messages
- Worker bootstrap code can reuse existing polling loop with modified context
- Registry and job systems already support multiple realms; minimal changes needed

---

## Technical Architecture: Remote Test Runner

### API Design Philosophy

**Goal**: Match Node.js `node:test` module API shape so agents can use the same mental model and code patterns across Node.js and browser contexts.

**Node.js test API reference**:
```javascript
import { test, describe, it } from 'node:test';
import assert from 'node:assert';

test('my test', () => { assert.equal(1, 1); });

describe('suite', () => {
  it('should work', () => { assert.ok(true); });
});
```

**Oyinbo Remote API** (exposed as global):

```javascript
// In browser/worker realm global scope:
const results = await globalThis.oyinboRunTests({
  files: ['./tests/example.test.js'],  // module paths to import
  timeout: 60000                        // per-test timeout (optional)
});
```

Results should include overall pass/fail status, counts, timing, and per-test details with names, outcomes, and error information. Format optimized for REPL log readability.

### Global Injection Strategy

**Test Primitives to Inject**:

1. **Test registration functions**:
   - `test(name, fn)` or `test(name, options, fn)`
   - `describe(name, fn)` (suite grouping)
   - `it(name, fn)` (alias for test within describe)

2. **Assertion library**:
   - Minimal Node.js-compatible `assert` object
   - Methods: `equal`, `strictEqual`, `ok`, `throws`, `rejects`, etc.
   - Throws `AssertionError` on failure (must have `.name`, `.message`, `.stack`)

3. **Runner function**:
   - `globalThis.oyinboRunTests(options)` triggers execution
   - Collects registered tests, runs them, returns structured results

### Execution Flow

**Agent-Initiated Test Run**:

1. Agent sends REPL command:
   ```javascript
   oyinboRunTests({ files: ['./my.test.js'] })
   ```

2. **In realm (browser/worker)**:
   - Clear previous test registry
   - Dynamically import specified test files (ESM `import()`)
   - Test files register themselves via `test()`, `describe()`, `it()` calls
   - After imports complete, iterate registered tests
   - Execute each test function, catch errors/rejections
   - Track pass/fail, timing, error details
   - Return comprehensive results object

3. **Server receives results**:
   - Standard REPL result handling (JSON payload)
   - Writes to chat log as normal (results serialized in JSON block)

### Test Isolation and Module Loading

**Module Context**:
- Tests are loaded as ES modules (`import()`)
- Each test file has own module scope (no global pollution between files)
- Test registration happens in global scope (collected by runner)

**State Management**:
- Test runs don't persist state (runner clears registry between runs)
- REPL state (variables, functions) remains untouched by test execution
- Tests can import and exercise application code from page/worker globals

**Cleanup**:
- After test run, remove test primitives from global scope (optional, configurable)
- Or keep them for debugging (agent can call `test()` directly in REPL)

### Compatibility Subset

**Full Node.js `node:test` compatibility is unnecessary**; focus on core subset:

**Included**:
- `test(name, fn)` — basic test definition with optional configuration
- `describe(name, fn)` — test grouping
- `it(name, fn)` — alias for test
- Async tests (return Promise or async function)
- Basic `assert` methods (equal, strictEqual, ok, throws, rejects)

**Excluded (initially)**:
- `before`, `after`, `beforeEach`, `afterEach` hooks (add later if needed)
- Subtests and nested test contexts
- Coverage collection (browser limitation)

### Caveats and Constraints

**Browser Module System**:
- ES modules only (no CommonJS `require()`)
- Test files must be accessible via URL (CORS, server routes)
- Dynamic imports may fail with restrictive CSP

**Timing and Async**:
- Per-test timeouts enforced to prevent hanging tests
- Unhandled rejections during test runs must be caught

**Error Reporting**:
- Stack traces may differ from Node.js (browser formatting)
- Source maps needed for minified/bundled code (future enhancement)

**State Leakage**:
- Tests modifying globals affect subsequent tests (runner doesn't sandbox)
- Agents should be aware of potential interference

### Implementation Considerations

**Test Runner Injection**:
- Test primitives and runner function injected into realm global scope
- Can inject at initialization or lazily when first requested
- Test results handled as normal REPL output (no special server changes needed)

**Core Components**:
- Test registration functions (`test`, `describe`, `it`)
- Basic assertion library compatible with Node.js patterns
- Test execution engine that imports files, runs tests, captures results
- Result formatting for REPL log output

---

## Integration and Rollout

### Development Phases

**Phase 1: Web Worker Realms**
- Implement worker creation in client.js
- Add heartbeat monitoring and restart logic
- Test across browsers (Chrome, Firefox, Safari)
- Document CSP requirements for successful worker creation

**Phase 2: Test Runner Core**
- Implement test primitives and runner logic
- Inject into main thread realms first (workers later)
- Validate against simple test files
- Document API and examples

**Phase 3: Test Runner in Workers**
- Extend test runner to worker realms
- Handle module import restrictions in workers

**Phase 4: Polish and Documentation**
- Add example test files to docs
- Create agent prompts for test-driven debugging workflows
- Performance optimization (lazy test runner injection)
- Error message improvements

### Testing Strategy

**Unit Tests** (Node.js environment):
- Test runner primitive behavior (registration, execution, assertions)
- Worker restart logic (mock Worker API)
- Heartbeat timeout calculations

**Integration Tests** (live server):
- Worker creation and registration in real browsers
- Test runner execution with sample test files
- Restart after intentional worker crashes
- Combined REPL + test runner workflows

### Documentation Artifacts

**User-Facing**:
- `docs/1.3-example-tests.md` — sample test files and patterns
- `docs/1.3-worker-debugging.md` — when to use workers vs main thread
- Update `README.md` with new capabilities

**Agent-Facing**:
- Prompt templates for test-driven debugging
- Common patterns: "run tests, analyze failures, apply fix, rerun"

---

## Success Criteria

**Web Worker Realms**:
- Workers created successfully in common browsers when CSP allows
- Unresponsive workers detected and restarted without manual intervention
- Main thread remains responsive during worker operations

**Test Runner**:
- API matches Node.js `node:test` core patterns for agent familiarity
- Tests execute reliably with clear pass/fail reporting
- Agents can validate fixes through automated test runs

## Implementation steps
 - Added served ES module worker bootstrap at `js/modules/worker-bootstrap.js` that implements the fetch-poll loop and executes jobs returned by `/oyinbo`.
    Reason: let module workers load from a real URL so they inherit import maps. Result: workers can bootstrap and run server jobs.
 - Exported `workerBootstrapModule` from `js/modules-loader.js` and wired it into the server module map.
    Reason: make the bootstrap code available to the server for serving. Result: server serves worker bootstrap content.
 - Added `/oyinbo/worker-bootstrap.js` to `OYINBO_MODULES` in `js/server.js` so the worker bootstrap is served from that URL.
    Reason: expose the bootstrap URL to browsers. Result: requests to that path return the bootstrap code.
 - Implemented import-map merging and injected mappings for `node:test` -> `/oyinbo/test-runner.js` and `node:assert` -> `/oyinbo/assert.js` in `js/server.js`.
    Reason: ensure pages and workers resolve test and assert imports consistently. Result: import maps include oyinbo module mappings.
 - Created `js/modules/test-runner.js` as an ES module exporting `test`, `describe`, `it`, `oyinboRunTests`, `assert`, and `AssertionError` (default export `assert`).
    Reason: provide a single ESM test-runner that can be imported by realms. Result: test API is available as named exports and a default assert.
 - Added `assertModule` in `js/modules-loader.js` which re-exports `assert`/`AssertionError` from `/oyinbo/test-runner.js` as `/oyinbo/assert.js`.
    Reason: offer `/oyinbo/assert.js` for import-map consumers that expect an assert module. Result: `import 'node:assert'` resolves to a compatible module.
 - Updated `js/client.js` to create a module worker from `location.origin + '/oyinbo/worker-bootstrap.js'`, implement ping/pong health checks, and attempt restarts on timeout.
    Reason: run workers reliably and detect hangs. Result: client creates named module workers and restarts unresponsive ones.
 - Updated `js/server.js` to serve Oyinbo module strings directly for `/oyinbo/*` paths and to inject the `clientScript` into served HTML pages.
    Reason: avoid filesystem copies and ensure clients receive the injection and modules. Result: server serves module text and injects the client script into HTML.
 - Implemented `sanitizeName()` in `js/client.js` for worker name generation, matching registry sanitization logic.
    Reason: ensure worker names match registry keys. Result: worker files no longer cross over with main page files.
 - Added `writeDiagnostic()` to `js/writer.js` for system-generated messages.
    Reason: enable server to write worker timeout diagnostics to chat logs. Result: timeout events appear in worker chat logs.
 - Implemented worker timeout diagnostics in `js/server.js` handleResult, writes timeout messages to worker chat logs.
    Reason: provide visibility into worker restart events. Result: timeout diagnostics appear in worker debug files.
 - Implemented `only` enforcement in `js/modules/test-runner.js`, skips non-only tests when any test has `only: true`.
    Reason: match Node.js test runner behavior. Result: `only` option filters test execution.
 - Implemented error validation in `assert.throws()` and `assert.rejects()` supporting constructor and regex validators.
    Reason: match Node.js assert API. Result: error type and message validation work correctly.
 - Implemented proper `deepEqualImpl()` in `js/modules/test-runner.js` handling dates, regexes, arrays, and objects recursively.
    Reason: replace fragile JSON.stringify approach. Result: deep equality works with circular refs and functions.
 - Added registry clearing in `oyinboRunTests()` after test execution completes.
    Reason: prevent test accumulation across runs. Result: tests don't carry over between test runs.
 - Implemented realm ID fallback chain in `getRealmId()`: sessionStorage → self.name → 'unknown'.
    Reason: support workers without sessionStorage access. Result: realm isolation works in all contexts.
 - Refactored `js/test-runner.js` to export module content from `js/modules/test-runner.js` for Node.js test harness compatibility.
    Reason: satisfy Node.js tests importing from './test-runner.js'. Result: test harness can load test runner module.


## Server control and debugging

During debugging and iteration, you may need to restart the server cleanly. The `debug.md` master registry supports a special shutdown command:

- **Shutdown command**: Add a line containing exactly `%%SHUTDOWN%%` to `debug.md`. The server will detect this and exit gracefully, allowing you to restart without terminating random Node.js processes or dealing with port conflicts.

Example usage:
1. Append `%%SHUTDOWN%%` to `debug.md`
2. Wait for server to exit cleanly
3. Restart the server with your changes

This is particularly useful when iterating on worker bootstrap code, test runner implementations, or server-side lifecycle logic.

## Unfinished business

Unit test functionality requires browser-based integration testing to verify end-to-end behavior.


---

## Future Enhancements

**Worker Realms**:
- Worker pools for parallel computation
- Dedicated workers for specific tasks (e.g., parsing, linting)
- Worker-to-worker communication (SharedArrayBuffer)

**Test Runner**:
- Coverage collection (via instrumentation)
- Snapshot testing (DOM snapshots, serialized state)
- Test hooks (`before`, `after`, `beforeEach`, `afterEach`)
- Performance benchmarking mode (measure execution time)
- Visual regression testing (screenshot comparison)

**Cross-Cutting**:
- Test runner in Python/LISP realms (extend beyond JS)
- Remote test execution across multiple browsers simultaneously
- Integration with CI/CD (agents trigger tests pre-commit)
