# Web Workers & Remote Test Runner — Expanding REPL Capabilities

## Broad Goal and Importance

The Oyinbo REPL currently provides powerful stateful remote execution in browser contexts, enabling AI agents to interact with live web pages. However, **real-world web applications impose constraints that limit debugging effectiveness**: main-thread blocking operations, page script interference, and security policies that prevent certain introspections. Additionally, **agents need the ability to validate code through automated testing**, not just one-off REPL evaluations.

These two features address critical gaps:

1. **Web Worker Realms** provide isolated, parallel execution contexts that remain responsive even when the main page is blocked or compromised
2. **Remote Test Runner** enables systematic validation through unit tests, transforming the REPL from an exploration tool into a comprehensive quality assurance platform

Together, they empower agents to **debug more complex scenarios, validate fixes systematically, and maintain code quality** — essential for autonomous software enhancement at scale.

---

## Auto-Created Web Worker Realms

### Purpose and Agent Benefits

Web worker realms run JavaScript in separate threads, isolated from the main page DOM and event loop. By automatically spawning these invisible worker realms alongside each page, agents gain:

- **Non-blocking execution**: Long-running computations or infinite loops won't freeze the REPL or page
- **Isolation from page interference**: Page scripts, content security policies, or monkey-patched globals won't corrupt REPL state
- **Parallel experimentation**: Test potentially destructive code without risking the main page context
- **Resilience**: Automatic restart and health monitoring ensure worker availability even after crashes

### User Control

- Worker realms appear in the master registry as separate entities (e.g., `7-zen-1201-03-webworker`)
- Agents can target commands to either the main page or its worker by name
- Workers are best-effort: if creation fails (CSP violations, browser limitations), the system gracefully continues with main thread only

---

## Remote Test Runner API

### Purpose and Agent Benefits

While REPL is excellent for exploration, **systematic validation requires running structured test suites**. The remote test runner provides:

- **Standard test primitives**: Node.js-compatible `test`, `describe`, `it`, assertions injected into realm globals
- **Automated test execution**: Import test files and run them remotely, receiving structured results
- **Quality gates**: Agents can validate fixes by running existing test suites against live application state
- **Compatibility**: Matching Node.js test runner API shape allows agents to use familiar patterns

### User Control

- Test runner API available via `import { run } from 'node:test'` matching Node.js conventions
- Agents can trigger test runs using glob patterns: `run({ files: ['**/*.test.js'] })`
- Server performs file discovery within project boundaries (document root)
- Results reported as structured markdown in REPL log with pass/fail counts and timing
- Supports both explicit file arrays and pattern-based discovery

---

## Technical Architecture: Web Worker Realms

### Initialization Flow

1. **Worker Creation**:
   - When browser client script initializes, attempt to create a web worker
   - Options include inline blob URLs, separate worker script files, or module workers
   - Consider reusing the same injection approach used for page-level REPL code
   - Worker name = `${mainPageName}-webworker` (e.g., `7-zen-1201-03-webworker`)
   - Creation wrapped in try-catch; failures logged but don't break main thread

2. **Worker Registration**:
   - Worker communicates with server identifying itself with its worker name
   - Registration parameters (name, URL/context) can be passed via headers, query params, or request body
   - Server treats worker as separate realm with its own chat log file in `debug/` directory
   - Master `debug.md` lists both page and worker as distinct entries

3. **Bidirectional Communication**:
   - Worker → Server: standard fetch polling loop (identical to main thread)
   - Main Thread → Worker: messaging for health checks and termination commands
   - Server has no direct worker reference; all control flows through main thread

### Heartbeat and Health Monitoring

**Goal**: Detect unresponsive workers and restart them automatically to maintain REPL availability.

**Main Thread Monitoring**:

- Periodically check worker responsiveness through message exchange
- Track missed responses to identify hung or crashed workers
- Balance frequent checks against unnecessary overhead

**Termination and Restart**:

- Terminate unresponsive workers and immediately attempt restart
- Send timeout/restart event to server for diagnostic logging
- Server writes diagnostic message to worker's chat log
- New worker reuses same name suffix and continues using existing chat log
- Consider restart throttling to avoid infinite restart loops

### Caveats and Constraints

**Browser Limitations**:
- CSP headers may block inline worker creation (`worker-src` directive)
- Some browsers don't support blob URLs for workers in certain contexts
- Workers have no DOM access (expected, but limits some debugging scenarios)

**Resource Management**:
- Workers consume memory/CPU; limit to 1 worker per page initially
- Consider future: worker pool for heavy parallelism

**Scope Differences**:
- Worker global is `self`, not `window`
- No access to `document`, `localStorage`, many Web APIs
- Code evaluated in worker must be worker-compatible

**Error Handling**:
- Worker creation failure is silent (logged to console, not REPL)
- Worker crashes without graceful shutdown require heartbeat detection
- Unhandled errors in worker should still post results back (same error capture as main thread)

### Implementation Touch Points

**Implementation Considerations**:

- Client script needs worker creation, health monitoring, and restart logic
- Server needs to handle worker lifecycle events (timeout/restart notifications)
- Writer component should support system-generated diagnostic messages
- Worker bootstrap code can reuse existing polling loop with modified context
- Registry and job systems already support multiple realms; minimal changes needed

---

## Technical Architecture: Remote Test Runner

### API Design Philosophy

**Goal**: Match Node.js `node:test` module API shape so agents can use the same mental model and code patterns across Node.js and browser contexts.

**Node.js test API reference**:
```javascript
import { test, describe, it } from 'node:test';
import assert from 'node:assert';

test('my test', () => { assert.equal(1, 1); });

describe('suite', () => {
  it('should work', () => { assert.ok(true); });
});
```

**Browser/Worker API** (via import map):

```javascript
// Node.js-compatible run() function
import { run } from 'node:test';

// Agent invokes from browser REPL - results stream to REPL log automatically
run({ files: ['**/*.test.js'] });

// Explicit file paths also supported
run({ files: ['./tests/example.test.js', './tests/another.test.js'] });
```

Test execution streams progress updates to the server automatically (debounced ~1-5 seconds). Results formatted as markdown and written to REPL log with special test result headers.

### Global Injection Strategy

**Test Primitives Available via Import**:

1. **Test registration functions**:
   - `test(name, fn)` or `test(name, options, fn)`
   - `describe(name, fn)` (suite grouping)
   - `it(name, fn)` (alias for test within describe)

2. **Assertion library**:
   - Minimal Node.js-compatible `assert` object
   - Methods: `equal`, `strictEqual`, `ok`, `throws`, `rejects`, etc.
   - Throws `AssertionError` on failure (must have `.name`, `.message`, `.stack`)

3. **Runner function**:
   - `run(options)` from `node:test` import (via import map)
   - Initiates test discovery, execution, and streaming results to server

**Injection Mechanisms**:

- **Import Maps**: Server injects mappings for `node:test` → `/oyinbo/test-runner.js` and `node:assert` → `/oyinbo/assert.js` into HTML pages
- **ES Modules**: Test primitives delivered as standard ES modules loaded via `import` statements
- **No Global Pollution**: Test primitives only accessible via explicit imports, matching Node.js behavior

### Execution Flow

**Agent-Initiated Test Run**:

1. Agent sends REPL command:
   ```javascript
   import { run } from 'node:test';
   run({ files: ['**/*.test.js'] });
   ```

2. **In realm (browser/worker)**:
   - Send test discovery request to server with glob pattern
   - Server scans project files and returns matching test file URLs
   - Dynamically import each discovered test file via ESM `import()`
   - Test files register themselves via imported `test()`, `describe()`, `it()` functions
   - After all imports complete, execute collected tests sequentially
   - Stream progress updates to server (debounced ~1-5 seconds) with current test status
   - Send final summary when all tests complete

3. **Server receives streaming results**:
   - Progress updates delivered via custom REPL message channel
   - Each update formatted as markdown with special test result headers
   - Markdown output written to chat log above footer incrementally
   - Final summary appended when test run completes

### Test Discovery and Execution Flow

**Architectural Overview**:

The test runner implements a hybrid client-server model that bridges browser REPL capabilities with Node.js-style test discovery. This enables agents to run project test suites without manually specifying file paths, matching the ergonomics of `node:test/run`.

**API Design**:

```javascript
// Node.js-compatible API exposed via import map
import { run } from 'node:test';

// Agent invokes from browser REPL - results stream automatically
run({ files: ['./tests/*.test.js'] });
```

**Execution Steps**:

**Step 1: Test File Discovery (Server-Side)**

When a test run is initiated from the browser REPL:

1. **Request**: Browser sends test discovery request to server endpoint `/oyinbo/discover-tests`
   - Payload includes glob pattern(s), optional root directory, exclusion patterns
   - Request tagged with realm ID for result routing

2. **Pattern Matching**: Server applies Node.js test runner file discovery rules:
   - Files matching `**/*.test.{js,mjs,cjs}`
   - Files matching `**/test-*.{js,mjs,cjs}`
   - Files in `test/` or `tests/` directories
   - Respects `.gitignore` and `node_modules` exclusions
   - Scoped to HTTP server document root and subdirectories

3. **Response**: Server returns array of discovered file paths:
   - Paths converted to HTTP URLs relative to server origin
   - Paths validated for accessibility (within document root, no path traversal)
   - Empty array if no matches (not an error condition)

**Step 2: Module Loading and Test Registration (Browser)**

After receiving file list from server:

1. **Module Import**: Browser realm dynamically imports each discovered test file:
   ```javascript
   for (const fileUrl of discoveredFiles) {
     await import(fileUrl);
   }
   ```
   - Import statements execute in ES module context
   - Test files import and use `test`, `describe`, `it`, `assert` from `node:test` and `node:assert`
   - Test files register themselves by calling imported test primitives during module initialization

2. **Test Collection**: Test registration functions accumulate tests in internal registry:
   - Each test stored with name, function, options, source file
   - Nested `describe()` blocks create hierarchical test structure
   - `only` and `skip` options respected during registration

3. **Isolation**: Each test file runs in its own ES module scope:
   - Local variables, imports, and exports don't leak between files
   - Global state (DOM, window properties) shared across all tests (by design)
   - Test registry is internal but cleared between full test runs

**Step 3: Test Execution (Browser)**

Once all test files loaded and registered:

1. **Execution Loop**: Runner iterates collected tests:
   - Respects `only` filtering (skip non-only tests if any test has `only: true`)
   - Wraps each test function in timeout handler (default 30s)
   - Catches both synchronous errors and promise rejections
   - Records start time, end time, pass/fail status

2. **Assertion Handling**: Test functions use imported `assert` methods:
   - Assertion failures throw `AssertionError` (caught by runner)
   - Error includes message, expected/actual values, stack trace
   - Non-assertion errors also caught and reported

3. **Result Aggregation**: Runner accumulates per-test results:
   - Test name, file, status (pass/fail/skip), duration, error details
   - Suite-level summaries (total, passed, failed, skipped)
   - Timing information (total duration, per-test breakdown)

**Step 4: Streaming Progress Updates (Browser → Server)**

During and after test execution:

1. **Periodic Updates**: Test runner sends progress updates to server (debounced ~1-5 seconds):
   ```javascript
   {
     type: 'test-progress',
     totals: { pass: 5, fail: 1, skip: 0, total: 10, running: 4 },
     duration: 567,  // ms elapsed
     recentTests: [
       { name: 'should work', file: './test/example.test.js', 
         status: 'pass', duration: 45 },
       { name: 'should fail', file: './test/broken.test.js', 
         status: 'fail', duration: 12, 
         error: { message: 'Expected 1 to equal 2', stack: '...' } }
     ]
   }
   ```

2. **Transport**: Updates sent via custom REPL message channel (not standard REPL result):
   - Separate endpoint or message type flag distinguishes from normal REPL output
   - Server recognizes test update payload by type field

3. **Markdown Formatting**: Server converts each update to markdown and writes to REPL log:
   - Special header format distinguishing test results from normal REPL output
   - Example header: `> realm-name test results` or `> realm-name tests: 5 pass, 1 fail`
   - Per-test details with indentation for describe blocks
   - Error messages and stack traces for failures
   - Inserted above footer in realm's debug log file

4. **Final Summary**: After all tests complete, send final update with complete results:
   - Includes full test list, final counts, total duration
   - Marked as final update (e.g., `complete: true`)
   - Server writes comprehensive summary to log

**Step 5: API Behavior**

For Node.js `run()` API compatibility:

1. **Side-Channel Streaming**: The `run()` function initiates test execution but doesn't return detailed results:
   - Function may return simple acknowledgment or undefined
   - All test results flow through REPL messaging side channel
   - Results appear in REPL log automatically without agent intervention

2. **No Event Emitter Required**: Unlike Node.js streaming API, no `.on()` or `.compose()` methods needed:
   - Browser implementation focuses on execution and messaging
   - Server handles all formatting and output presentation
   - Simplifies browser-side implementation

**State Management and Isolation**:

- **Test Registry Clearing**: Internal registry cleared before and after each full test run to prevent accumulation
- **Module Caching**: Browser caches imported modules; force reload requires cache busting or page refresh
- **Global State Leakage**: Tests can modify global state; runner does not sandbox or restore
- **REPL State Preservation**: REPL variables and state unaffected by test execution (separate module contexts)
- **No Global Pollution**: Test primitives (`test`, `describe`, `it`, `assert`) only accessible via explicit imports from `node:test` and `node:assert`

**Error Handling and Edge Cases**:

- **Discovery Failures**: If server cannot find files, returns empty array (test run succeeds with 0 tests)
- **Import Failures**: If test file import fails, treated as single test failure for that file
- **Timeout Handling**: Tests exceeding timeout limit marked as failed with timeout error
- **Unhandled Rejections**: Captured and attributed to currently executing test
- **Worker Compatibility**: Same mechanism works in web worker realms (workers can import modules)

### Compatibility Subset

**Full Node.js `node:test` compatibility is unnecessary**; focus on core subset:

**Included**:
- `test(name, fn)` — basic test definition with optional configuration
- `describe(name, fn)` — test grouping
- `it(name, fn)` — alias for test
- Async tests (return Promise or async function)
- Basic `assert` methods (equal, strictEqual, ok, throws, rejects)

**Excluded (initially)**:
- `before`, `after`, `beforeEach`, `afterEach` hooks (add later if needed)
- Subtests and nested test contexts
- Coverage collection (browser limitation)

### Caveats and Constraints

**Browser Module System**:
- ES modules only (no CommonJS `require()`)
- Test files discovered by server must be accessible via HTTP URLs
- Browser imports discovered files as modules (subject to CORS and CSP)
- Server-side discovery limited to document root and subdirectories (no path traversal)
- Glob patterns resolved server-side using Node.js filesystem access

**Timing and Async**:
- Per-test timeouts enforced to prevent hanging tests
- Unhandled rejections during test runs must be caught

**Error Reporting**:
- Stack traces may differ from Node.js (browser formatting)
- Source maps needed for minified/bundled code (future enhancement)

**State Leakage**:
- Tests modifying globals affect subsequent tests (runner doesn't sandbox)
- Agents should be aware of potential interference

### Implementation Considerations

**Test Runner Components**:

1. **Browser-Side**:
   - Test registration functions (`test`, `describe`, `it`) exported from ES module
   - Assertion library compatible with Node.js patterns
   - Test execution engine that imports files, runs tests, captures results
   - Progress streaming to server (debounced updates every ~1-5 seconds)
   - Side-channel messaging for test updates (separate from normal REPL results)

2. **Server-Side**:
   - `/oyinbo/discover-tests` endpoint accepting glob patterns
   - File discovery using Node.js test runner naming conventions
   - Path validation and URL conversion
   - Test progress receiver that formats updates as markdown with special headers
   - Integration with REPL log writer for incremental result output

3. **Import Map Infrastructure**:
   - Server injects `node:test` and `node:assert` mappings into HTML
   - Test runner module served at `/oyinbo/test-runner.js`
   - Assert module served at `/oyinbo/assert.js`
   - Both main thread and worker realms inherit import maps

**Core Workflows**:
- **Pattern-based discovery**: Browser requests → server discovers → browser imports → executes → streams updates → server formats → log written
- **Explicit file list**: Browser imports → executes → streams updates → server formats → log written
- **Result streaming**: Periodic progress updates (debounced) + final summary, all via custom message channel

---

## Integration and Rollout

### Development Phases

**Phase 1: Web Worker Realms**
- Implement worker creation in client.js
- Add heartbeat monitoring and restart logic
- Test across browsers (Chrome, Firefox, Safari)
- Document CSP requirements for successful worker creation

**Phase 2: Test Runner Core**
- Implement test primitives and runner logic
- Inject into main thread realms first (workers later)
- Validate against simple test files
- Document API and examples

**Phase 3: Test Runner in Workers**
- Extend test runner to worker realms
- Handle module import restrictions in workers

**Phase 4: Polish and Documentation**
- Add example test files to docs
- Create agent prompts for test-driven debugging workflows
- Performance optimization (lazy test runner injection)
- Error message improvements

### Testing Strategy

**Unit Tests** (Node.js environment):
- Test runner primitive behavior (registration, execution, assertions)
- Worker restart logic (mock Worker API)
- Heartbeat timeout calculations
- Glob pattern matching and file discovery logic
- Path validation and URL conversion
- Markdown result formatting

**Integration Tests** (live server + browser):
- Worker creation and registration in real browsers
- Test file discovery via `/oyinbo/discover-tests` endpoint
- Module import and test registration flow
- Full test execution with passing and failing tests
- Result transmission and markdown formatting
- Combined REPL + test runner workflows
- Pattern-based vs explicit file list modes

### Documentation Artifacts

**User-Facing**:
- `docs/1.3-example-tests.md` — sample test files and patterns
- `docs/1.3-worker-debugging.md` — when to use workers vs main thread
- Update `README.md` with new capabilities

**Agent-Facing**:
- Prompt templates for test-driven debugging
- Common patterns: "run tests, analyze failures, apply fix, rerun"

---

## Success Criteria

**Web Worker Realms**:
- Workers created successfully in common browsers when CSP allows
- Unresponsive workers detected and restarted without manual intervention
- Main thread remains responsive during worker operations

**Test Runner**:
- API matches Node.js `node:test` core patterns for agent familiarity
- Tests execute reliably with clear pass/fail reporting
- Agents can validate fixes through automated test runs

## Implementation steps
 - Added served ES module worker bootstrap at `js/modules/worker-bootstrap.js` that implements the fetch-poll loop and executes jobs returned by `/oyinbo`.
    Reason: let module workers load from a real URL so they inherit import maps. Result: workers can bootstrap and run server jobs.
 - Exported `workerBootstrapModule` from `js/modules-loader.js` and wired it into the server module map.
    Reason: make the bootstrap code available to the server for serving. Result: server serves worker bootstrap content.
 - Added `/oyinbo/worker-bootstrap.js` to `OYINBO_MODULES` in `js/server.js` so the worker bootstrap is served from that URL.
    Reason: expose the bootstrap URL to browsers. Result: requests to that path return the bootstrap code.
 - Implemented import-map merging and injected mappings for `node:test` -> `/oyinbo/test-runner.js` and `node:assert` -> `/oyinbo/assert.js` in `js/server.js`.
    Reason: ensure pages and workers resolve test and assert imports consistently. Result: import maps include oyinbo module mappings.
 - Created `js/modules/test-runner.js` as an ES module exporting `test`, `describe`, `it`, `oyinboRunTests`, `assert`, and `AssertionError` (default export `assert`).
    Reason: provide a single ESM test-runner that can be imported by realms. Result: test API is available as named exports and a default assert.
 - Added `assertModule` in `js/modules-loader.js` which re-exports `assert`/`AssertionError` from `/oyinbo/test-runner.js` as `/oyinbo/assert.js`.
    Reason: offer `/oyinbo/assert.js` for import-map consumers that expect an assert module. Result: `import 'node:assert'` resolves to a compatible module.
 - Updated `js/client.js` to create a module worker from `location.origin + '/oyinbo/worker-bootstrap.js'`, implement ping/pong health checks, and attempt restarts on timeout.
    Reason: run workers reliably and detect hangs. Result: client creates named module workers and restarts unresponsive ones.
 - Updated `js/server.js` to serve Oyinbo module strings directly for `/oyinbo/*` paths and to inject the `clientScript` into served HTML pages.
    Reason: avoid filesystem copies and ensure clients receive the injection and modules. Result: server serves module text and injects the client script into HTML.
 - Implemented `sanitizeName()` in `js/client.js` for worker name generation, matching registry sanitization logic.
    Reason: ensure worker names match registry keys. Result: worker files no longer cross over with main page files.
 - Added `writeDiagnostic()` to `js/writer.js` for system-generated messages.
    Reason: enable server to write worker timeout diagnostics to chat logs. Result: timeout events appear in worker chat logs.
 - Implemented worker timeout diagnostics in `js/server.js` handleResult, writes timeout messages to worker chat logs.
    Reason: provide visibility into worker restart events. Result: timeout diagnostics appear in worker debug files.
 - Implemented `only` enforcement in `js/modules/test-runner.js`, skips non-only tests when any test has `only: true`.
    Reason: match Node.js test runner behavior. Result: `only` option filters test execution.
 - Implemented error validation in `assert.throws()` and `assert.rejects()` supporting constructor and regex validators.
    Reason: match Node.js assert API. Result: error type and message validation work correctly.
 - Implemented proper `deepEqualImpl()` in `js/modules/test-runner.js` handling dates, regexes, arrays, and objects recursively.
    Reason: replace fragile JSON.stringify approach. Result: deep equality works with circular refs and functions.
 - Added registry clearing in `oyinboRunTests()` after test execution completes.
    Reason: prevent test accumulation across runs. Result: tests don't carry over between test runs.
 - Implemented realm ID fallback chain in `getRealmId()`: sessionStorage → self.name → 'unknown'.
    Reason: support workers without sessionStorage access. Result: realm isolation works in all contexts.
 - Refactored `js/test-runner.js` to export module content from `js/modules/test-runner.js` for Node.js test harness compatibility.
    Reason: satisfy Node.js tests importing from './test-runner.js'. Result: test harness can load test runner module.

### Pending implementation for server-side test discovery:
 - **TODO**: Add `/oyinbo/discover-tests` endpoint in `js/server.js` accepting POST with `{ pattern, cwd, exclude }` parameters.
    Reason: enable server-side test file discovery. Result: browser can request file list without knowing paths.
 - **TODO**: Implement glob matching using Node.js `fs` and pattern library (minimatch or similar).
    Reason: match Node.js test runner file discovery conventions. Result: finds `**/*.test.js`, `test-*.js`, files in `test/` dirs.
 - **TODO**: Add path validation to prevent directory traversal and limit to document root.
    Reason: security - prevent access to files outside served directory. Result: only project files discoverable.
 - **TODO**: Implement `run(options)` function in `js/modules/test-runner.js` that calls discovery endpoint and streams results.
    Reason: provide Node.js-compatible run API. Result: agents can use `import { run } from 'node:test'`.
 - **TODO**: Add progress streaming in test runner that sends debounced updates (~1-5 seconds) to server during execution.
    Reason: provide real-time test progress visibility. Result: agents see test results as they happen, not just final summary.
 - **TODO**: Implement custom message channel for test updates (separate from normal REPL result mechanism).
    Reason: distinguish test streaming from normal code execution. Result: server can format test updates with special headers.
 - **TODO**: Implement markdown result formatter on server that converts test progress updates to readable output with special headers.
    Reason: display test results distinctly in REPL log. Result: test updates clearly marked (e.g., `> realm-name tests: 5 pass, 1 fail`).
 - **TODO**: Integrate streaming test result writing into `js/writer.js` with incremental updates above footer.
    Reason: show test progress as it happens. Result: test reports appear incrementally in log during execution.


## Server control and debugging

During debugging and iteration, you may need to restart the server cleanly. The `debug.md` master registry supports a special shutdown command:

- **Shutdown command**: Add a line containing exactly `%%SHUTDOWN%%` to `debug.md`. The server will detect this and exit gracefully, allowing you to restart without terminating random Node.js processes or dealing with port conflicts.

Example usage:
1. Append `%%SHUTDOWN%%` to `debug.md`
2. Wait for server to exit cleanly
3. Restart the server with your changes

This is particularly useful when iterating on worker bootstrap code, test runner implementations, or server-side lifecycle logic.

## Unfinished business

Unit test functionality requires several components to be implemented:

1. **Server-side test discovery**: `/oyinbo/discover-tests` endpoint with glob pattern matching and file enumeration
2. **Browser-side run() API**: Implementation of `node:test` run function that coordinates discovery, import, and execution
3. **Progress streaming**: Debounced test result updates (~1-5 seconds) sent from browser to server during execution
4. **Custom message channel**: Separate transport for test updates distinct from normal REPL results
5. **Result formatting**: Markdown formatter on server with special headers for test updates (e.g., `> realm-name tests: 5 pass, 1 fail`)
6. **Incremental log writing**: Server writes streaming test updates to REPL log above footer as they arrive
7. **Integration testing**: End-to-end validation of discovery → import → execute → stream → format → log flow


---

## Future Enhancements

**Worker Realms**:
- Worker pools for parallel computation
- Dedicated workers for specific tasks (e.g., parsing, linting)
- Worker-to-worker communication (SharedArrayBuffer)

**Test Runner**:
- Coverage collection (via instrumentation)
- Snapshot testing (DOM snapshots, serialized state)
- Test hooks (`before`, `after`, `beforeEach`, `afterEach`)
- Performance benchmarking mode (measure execution time)
- Visual regression testing (screenshot comparison)

**Cross-Cutting**:
- Test runner in Python/LISP realms (extend beyond JS)
- Remote test execution across multiple browsers simultaneously
- Integration with CI/CD (agents trigger tests pre-commit)
