# Unit Testing Plan — Oyinbo REPL

## Testing Framework

Use Node.js built-in test runner (`node:test`) with zero external dependencies. Run tests with:

```bash
node --test test/**/*.test.js
```

## Core Testing Principles

### One Test, One Assertion

Each test should verify exactly ONE behavior with ONE assertion. 

**To verify multiple fields of an object, use structural equality** (`assert.deepStrictEqual`) — this is a single assertion that checks the entire shape:

```javascript
test('parseRequest returns complete request object', () => {
  const input = '> Write code in a fenced JS block below\n> **agent** to page at 12:34:56\n```js\nx\n```';
  const result = parseRequest(input, 'page');
  assert.deepStrictEqual(result, {
    agent: 'agent',
    target: 'page',
    time: '12:34:56',
    code: 'x',
    hasFooter: true
  });
});
```

Multiple assertions in a single test are exceptionally rare and should be avoided. If you find yourself needing more than one assertion, split into separate tests

### Clear, Literal Tests

**DO:**
```javascript
test('parseRequest extracts code from footer-based request', () => {
  const input = '> Write code in a fenced JS block below\n```js\n1 + 1\n```';
  const result = parseRequest(input, 'test-page');
  assert.strictEqual(result.code, '1 + 1');
});
```

**DON'T:**
```javascript
// Avoid data-driven tests
const cases = [
  { input: '...', expected: '...' },
  { input: '...', expected: '...' }
];
for (const { input, expected } of cases) {
  test(`case ${input}`, () => { ... });
}

// Avoid complex setup
function setupComplexScenario(options) { ... }
```

### Test Structure

```javascript
import { test } from 'node:test';
import assert from 'node:assert/strict';
import { functionToTest } from '../js/module.js';

test('brief description of what is tested', () => {
  // Arrange: literal inputs
  const input = 'concrete value';
  
  // Act: call function
  const result = functionToTest(input);
  
  // Assert: one clear check
  assert.strictEqual(result, 'expected value');
});
```

## Assertion Patterns

### Pattern 1: Strict Equality (primitives)

```javascript
assert.strictEqual(actual, expected);
// Produces: AssertionError: Expected values to be strictly equal:
// 'foo' !== 'bar'
```

### Pattern 2: Deep Equality (objects/arrays)

```javascript
assert.deepStrictEqual(actual, expected);
// Produces: AssertionError: Expected values to be deeply strictly equal:
// { code: 'x' } !== { code: 'y' }
```

### Pattern 3: Truthiness

```javascript
assert.ok(value);  // truthy
assert.ok(!value); // falsy
// Produces: AssertionError: The expression evaluated to a falsy value
```

### Pattern 4: Null/Undefined

```javascript
assert.strictEqual(value, null);
assert.strictEqual(value, undefined);
```

### Pattern 5: Type Check

```javascript
assert.strictEqual(typeof value, 'string');
assert.ok(Array.isArray(value));
```

### Pattern 6: Regex Match

```javascript
assert.match(string, /pattern/);
// Produces: AssertionError: The input did not match the regular expression /pattern/
```

### Pattern 7: Exception Testing

```javascript
assert.throws(
  () => { functionThatThrows(); },
  /expected error message/
);
```

## Priority Areas for Testing

### High Priority: Pure Logic (Easy to Test)

#### 1. `parser.js` — parseRequest()

**Why:** Pure function, no side effects, critical path.

**Test Coverage:**
- Footer-based request with agent header
- Footer-based request without agent header  
- No-footer request with fenced block
- Empty/whitespace after footer returns null
- Page reply header above fence returns null
- Fence without code returns null
- Multiple fences extracts last one
- Code fence with `js`, `javascript`, or no language tag
- Whitespace handling in headers

**Example:**
```javascript
test('parseRequest returns null when chunk after footer is empty', () => {
  const input = '> Write code in a fenced JS block below\n   \n';
  const result = parseRequest(input, 'test-page');
  assert.strictEqual(result, null);
});
```

#### 2. Helper Functions in `registry.js`

**Why:** Internal pure functions with clear inputs/outputs.

**Test Coverage:**
- `sanitizeName()`: lowercase, dash replacement, trim edges
- `clockFmt()`: time formatting with padding

**Example:**
```javascript
test('sanitizeName converts to lowercase', () => {
  const result = sanitizeName('MyPage-123');
  assert.strictEqual(result, 'mypage-123');
});

test('sanitizeName replaces non-alphanumeric with dash', () => {
  const result = sanitizeName('foo@bar#baz');
  assert.strictEqual(result, 'foo-bar-baz');
});

test('clockFmt pads single digits', () => {
  const ms = new Date('2025-01-01T03:04:05').getTime();
  const result = clockFmt(ms);
  assert.strictEqual(result, '03:04:05');
});
```

#### 3. Helper Functions in `writer.js`

**Why:** Line-parsing logic is pure and error-prone.

**Test Coverage:**
- `findFooter()`: locates footer from bottom
- `findLastFencedBlock()`: locates last complete fence
- `findAgentHeaderAbove()`: finds header skipping blanks
- `buildBlocks()`: formats success/error/background events
- `durationFmt()`: ms vs seconds formatting

**Example:**
```javascript
test('findFooter returns index of footer line', () => {
  const lines = ['line1', 'line2', '> Write code in a fenced JS block', 'line4'];
  const result = findFooter(lines);
  assert.strictEqual(result, 2);
});

test('findFooter returns -1 when footer not found', () => {
  const lines = ['line1', 'line2'];
  const result = findFooter(lines);
  assert.strictEqual(result, -1);
});

test('durationFmt returns ms for values under 2000', () => {
  assert.strictEqual(durationFmt(500), '500ms');
});

test('durationFmt returns seconds for values 2000 and above', () => {
  assert.strictEqual(durationFmt(2500), '2.5s');
});
```

### Medium Priority: Stateful Logic (Requires Mocking/Stubs)

#### 4. `job.js` — Job Lifecycle

**Why:** State management is critical but requires time mocking.

**Test Coverage:**
- `create()`: initializes job with correct fields
- `get()`: retrieves by page name
- `finish()`: clears timeout and interval, updates page state

**Note:** Avoid testing timeout behavior directly (uses real timers). Instead test that timeout is set and cleared.

**Example:**
```javascript
test('create sets job fields correctly', () => {
  const page = { name: 'test', state: 'idle', file: '/tmp/test.md' };
  const job = create(page, 'agent', 'code', true);
  
  assert.strictEqual(job.agent, 'agent');
  assert.strictEqual(job.code, 'code');
  assert.strictEqual(job.requestHasFooter, true);
});

test('finish sets page state to idle', () => {
  const page = { name: 'test', state: 'executing', file: '/tmp/test.md' };
  const job = create(page, 'agent', 'code');
  finish(job);
  
  assert.strictEqual(page.state, 'idle');
});
```

#### 5. `registry.js` — Page Management

**Why:** File I/O and state, but can use temp directories.

**Test Coverage:**
- `getOrCreate()`: creates new page
- `getOrCreate()`: returns existing page
- `get()`: retrieves by name
- `all()`: returns array of pages

**Setup:** Use `node:fs` with temp directory for each test.

**Example:**
```javascript
import { mkdtempSync, rmSync } from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';

test('getOrCreate creates new page when not exists', () => {
  const root = mkdtempSync(join(tmpdir(), 'oyinbo-test-'));
  try {
    const page = getOrCreate(root, 'test-page', 'http://localhost');
    assert.strictEqual(page.name, 'test-page');
    assert.strictEqual(page.url, 'http://localhost');
  } finally {
    rmSync(root, { recursive: true, force: true });
  }
});
```

### Low Priority: Integration/System Level

#### 6. `writer.js` — File Writing

**Why:** Complex file manipulation, best tested via integration.

**Recommendation:** Focus on testing helper functions (high priority above). Test `writeReply()` and `writeExecuting()` with a few key scenarios using temp files.

#### 7. `watcher.js` — File Watching

**Why:** Async, timing-dependent, fs watching.

**Recommendation:** Test only the `check` logic indirectly through parser tests. Skip direct watcher testing.

#### 8. `server.js`, `client.js`

**Why:** HTTP/browser runtime, best tested via E2E.

**Recommendation:** Skip unit tests. Consider separate E2E test suite.

## Test File Organization

```
test/
  parser.test.js       - parseRequest tests
  registry.test.js     - page management, sanitizeName, clockFmt
  writer.test.js       - helper functions (findFooter, buildBlocks, etc)
  job.test.js          - job lifecycle
```

## Test Coverage

### Option 1: Node.js Built-in Coverage (v22.0.0+)

```bash
node --test --experimental-test-coverage test/**/*.test.js
```

Produces coverage summary in terminal.

### Option 2: c8 (Minimal External Tool)

```bash
npm install --save-dev c8
npx c8 node --test test/**/*.test.js
```

Produces detailed HTML report.

### Coverage Goals

- **parser.js**: aim for 95%+ (pure logic, no excuse)
- **registry.js helpers**: aim for 90%+
- **writer.js helpers**: aim for 85%+
- **job.js**: aim for 70%+ (avoid timeout edge cases)

## Running Tests

### Single test file:
```bash
node --test test/parser.test.js
```

### All tests:
```bash
node --test test/**/*.test.js
```

### With coverage:
```bash
node --test --experimental-test-coverage test/**/*.test.js
```

### Watch mode:
```bash
node --test --watch test/**/*.test.js
```

## Example Complete Test File

```javascript
// test/parser.test.js
import { test } from 'node:test';
import assert from 'node:assert/strict';
import { parseRequest } from '../js/parser.js';

test('parseRequest extracts code from footer-based request with header', () => {
  const input = [
    '> Write code in a fenced JS block below',
    '> **agent** to test-page at 12:34:56',
    '```js',
    'console.log("hello")',
    '```'
  ].join('\n');
  
  const result = parseRequest(input, 'test-page');
  
  assert.strictEqual(result.code, 'console.log("hello")');
});

test('parseRequest extracts agent from header', () => {
  const input = [
    '> Write code in a fenced JS block below',
    '> **alice** to test-page at 12:34:56',
    '```js',
    'x',
    '```'
  ].join('\n');
  
  const result = parseRequest(input, 'test-page');
  
  assert.strictEqual(result.agent, 'alice');
});

test('parseRequest returns null when no code after footer', () => {
  const input = '> Write code in a fenced JS block below\n\n  ';
  const result = parseRequest(input, 'test-page');
  assert.strictEqual(result, null);
});

test('parseRequest returns null when fence is empty', () => {
  const input = [
    '> Write code in a fenced JS block below',
    '```js',
    '   ',
    '```'
  ].join('\n');
  
  const result = parseRequest(input, 'test-page');
  assert.strictEqual(result, null);
});
```

## Anti-Patterns to Avoid

### ❌ Data-Driven Tests
```javascript
// DON'T
const testCases = [...];
for (const tc of testCases) { test(...) }
```

### ❌ Complex Setup Functions
```javascript
// DON'T
function createComplexScenario(opts) { ... }
test('...', () => {
  const scenario = createComplexScenario({ mode: 'advanced', ... });
  ...
});
```

### ❌ Multiple Assertions Per Test
```javascript
// DON'T - use deepStrictEqual instead
test('parseRequest works', () => {
  const result = parseRequest(...);
  assert.strictEqual(result.code, '...');
  assert.strictEqual(result.agent, '...');
  assert.strictEqual(result.hasFooter, true);
});

// DO - single structural assertion
test('parseRequest returns correct object', () => {
  const result = parseRequest(...);
  assert.deepStrictEqual(result, {
    code: '...',
    agent: '...',
    hasFooter: true
  });
});
```

### ❌ Testing Implementation Details
```javascript
// DON'T test that internals call other internals
test('writeReply calls buildBlocks', () => { ... });
```

## Summary

Focus testing effort on:
1. **parser.js** — highest ROI, pure logic
2. **Helper functions** in registry.js and writer.js
3. **job.js** — state management basics

Keep tests simple, literal, and focused. One test, one assertion. Clear failures that point directly to the problem.
