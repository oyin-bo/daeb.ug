# Background Event Capture â€” Real-Time Runtime Diagnostics

## Purpose and Agent Benefits

The ðŸ‘¾Daebug REPL executes JavaScript in live browser and worker contexts, but **execution results alone tell an incomplete story**. Real-world debugging requires visibility into **background runtime activity** that happens outside the direct REPL evaluation: unhandled errors from asynchronous operations, console output from libraries, and runtime warnings from the platform itself.

**Without background event capture**, agents are blind to:
- Errors thrown in setTimeout/setInterval callbacks that fire after REPL code returns
- Promise rejections that occur asynchronously 
- Console output from third-party libraries or application code triggered by REPL actions
- Runtime warnings about deprecated APIs, security violations, or resource constraints

**With background event capture**, agents gain:
- **Complete diagnostic context**: See all runtime activity triggered by REPL commands, not just return values
- **Asynchronous debugging**: Track down errors that manifest after REPL code completes
- **Library introspection**: Observe console output from code the agent didn't write
- **Platform visibility**: Detect browser warnings and errors that affect execution environment

This transforms the REPL from a simple expression evaluator into a **comprehensive runtime observatory** where agents can observe the full consequences of their actions.

---

## Functional Requirements

As specified in [1-jsrepl.md](1-jsrepl.md#background-capture-global-errors-and-console-events), background capture MUST support:

### Event Types

1. **Unhandled Errors**:
   - `window.onerror` / `self.onerror` (syntax errors, runtime errors in callbacks)
   - `unhandledrejection` (promise rejections without catch handlers)
   - Full stack traces captured and preserved

2. **Console Output**:
   - `console.log` â€” informational messages
   - `console.info` â€” informational messages  
   - `console.warn` â€” warnings
   - `console.error` â€” explicit errors
   - Arguments serialized to strings (JSON for objects when possible)

### Output Format

- **Structured events**: Each captured event has `{type, level, ts, message, stack?}` where `ts` is `HH:MM:SS` timestamp
- **Fence metadata**: Output uses specialized fence info strings like ````Error window.onerror```` or ````JSON console.log```` to distinguish event sources
- **Attachment to REPL replies**: Background events append immediately after REPL result blocks, grouped with the job that triggered them
- **Chronological ordering**: Events appear in the order they occurred
- **Truncation**: When more than 10 events captured, show first 2, ellipsis with count, then last 8

### Lifecycle and Timing

- **Collection window**: Capture events from job start (`startedAt`) until completion (`finishedAt`)
- **In-flight visibility**: During long-running jobs, stream background events to log in real-time (debounced to avoid excessive writes)
- **Background-only flush**: When no REPL job is active but background events occur, write them with special header format
- **Realm isolation**: Each realm (page, worker) maintains independent background event buffers

---

## Architectural Design

### Client-Side Capture Layer

The capture layer lives in the realm (browser main thread or web worker) and intercepts runtime events before they reach default handlers. This layer must be **transparent** (doesn't alter normal behavior) and **comprehensive** (catches events regardless of how they're generated).

#### Error Interception

**Mechanism**: Register global error handlers that capture event details then allow default behavior to continue.

**Challenge**: Platform event handlers receive raw event objects with inconsistent shapes. The capture layer must normalize these into structured event records with reliable timestamp, message, and stack extraction.

**Timing consideration**: Error handlers fire synchronously when errors occur. Capture must be fast to avoid impacting application performance. Use lightweight data structures and defer expensive serialization until transmission time.

**Edge cases**:
- Errors thrown during REPL evaluation itself (already handled by try-catch) should not duplicate in background buffer
- Errors from previous REPL jobs should not leak into new job buffers
- Multiple errors in quick succession should all be captured, not just the first

#### Console Interception  

**Mechanism**: Monkeypatch (wrap) console methods, preserving original behavior while capturing arguments.

**Challenge**: Console methods accept multiple arguments of any type. The capture layer must serialize these to strings without causing side effects (no triggering getters, no infinite recursion on circular structures).

**Serialization strategy**:
- Primitives: use String() coercion
- Objects: attempt JSON.stringify() with try-catch, fall back to String() or `[object Object]` on failure
- Functions: use function name or `[Function]` placeholder
- Arrays: serialize elements with recursion depth limit
- Circular references: detect and replace with `[Circular]` marker

**Preservation**: After capturing arguments, call the original console method so output still appears in DevTools. This maintains developer experience while enabling REPL visibility.

#### Event Buffer Management

**Structure**: Each realm maintains an in-memory array of background events. Each entry is an object with standardized shape: `{type, level, ts, message, stack?}`.

**Lifecycle**:
- **Initialization**: Buffer starts empty when realm connects to server
- **Accumulation**: As events fire, append to buffer with current timestamp
- **Association**: When REPL job starts, mark buffer position. Events after this mark belong to this job.
- **Transmission**: When REPL job completes, include accumulated events in result payload
- **Truncation**: Apply 10-event limit (first 2 + ellipsis + last 8) before transmission
- **Reset**: Clear job-specific events after transmission; retain unassociated events for background-only flush

**Memory bounds**: Limit total buffer size (e.g., 50 events max) to prevent memory leaks during long-running pages. When limit reached, drop oldest events outside current job window.

### Server-Side Formatting Layer

The server receives structured event arrays from realms and formats them as Markdown fenced blocks for insertion into per-instance chat logs.

#### Event to Markdown Translation

**Input**: Array of `{type, level, ts, message, stack?}` objects from client

**Output**: Array of Markdown fenced blocks with appropriate language tags and metadata

**Mapping rules**:
- `type: 'error'` â†’ ````Error window.onerror```` or ````Error unhandledrejection```` (extract event source from context)
- `type: 'console', level: 'log'` â†’ ````JSON console.log```` (use JSON if message is structured, else Text)
- `type: 'console', level: 'warn'` â†’ ````Text console.warn````
- `type: 'console', level: 'info'` â†’ ````Text console.info````  
- `type: 'console', level: 'error'` â†’ ````Error console.error````

**Content**: For errors, use full stack trace. For console output, use serialized message string.

**Metadata preservation**: Timestamps are implicit in event order and job headers; don't duplicate `ts` in every block. The reply header shows job completion time which bounds all background events.

#### Placement in Chat Log

**Standard flow** (events associated with REPL job):

```
> **page-name** to agent at HH:MM:SS (duration)
```JSON
<REPL result>
```
```Error window.onerror
<background error stack>
```
```JSON console.log
<console output>
```

----------------------------------------------------------------------
```

**Key principle**: No blank line between result block and first background block. Background blocks flow directly after result. Blank line only after all blocks complete, before horizontal rule.

**Background-only flow** (events occur when no REPL job active):

```
> **page-name** background at HH:MM:SS
```Error unhandledrejection
<error stack>
```
```Text console.warn
<warning message>
```

----------------------------------------------------------------------
```

This handles cases where page/worker generates errors or logs outside REPL execution windows (e.g., from timers set by previous commands, or from page's own application code).

### Protocol Extensions

The existing result payload `{ok, value?, error?, errors[], jobId}` must evolve to support structured background events.

#### Payload Changes

**Current**: `errors` is string array of raw error messages/stacks

**Proposed**: Rename to `backgroundEvents` and change to structured array:

```javascript
{
  ok: boolean,
  value?: any,
  error?: string,
  backgroundEvents: Array<{
    type: 'error' | 'console',
    level?: 'log' | 'info' | 'warn' | 'error',
    source?: 'window.onerror' | 'unhandledrejection',
    ts: string,  // HH:MM:SS
    message: string,
    stack?: string
  }>,
  jobId: string
}
```

**Backward compatibility**: Server can accept both `errors` (legacy string array) and `backgroundEvents` (new structured array) during transition. Writer component checks for `backgroundEvents` first, falls back to `errors` if absent.

#### Background-Only Messages

**New message type**: When client has background events but no REPL job to attach them to, send a dedicated message:

```javascript
POST /daebug?name=<realm-name>&url=<realm-url>
{
  type: 'background-flush',
  events: Array<{type, level, source?, ts, message, stack?}>,
  timestamp: <server-side timestamp or client ts>
}
```

**Server handling**: Writer recognizes `type: 'background-flush'`, formats events as Markdown blocks, inserts with background-only header format above footer in realm's chat log.

**Trigger**: Client sends background-only flush when:
- Background buffer reaches threshold (e.g., 5+ unassociated events)
- Periodic timer fires (e.g., every 10 seconds if buffer non-empty)
- Realm about to close/unload and events remain

### Real-Time Streaming During Long Jobs

As specified in [1-jsrepl.md](1-jsrepl.md#footer-anchor-and-dynamic-lifecycle-detailed), during job execution the server can update the executing region with background text.

#### Streaming Mechanism

**Challenge**: Jobs may run for seconds or minutes (e.g., animations, polling loops, async operations). Agents need to see background events as they happen, not just after job completes.

**Solution**: Client sends periodic progress updates while job is running. Server swaps background text in the executing region without disturbing the placeholder.

**Client behavior**:
- While job executing, check background buffer every 2-5 seconds
- If new events accumulated since last update, send progress message to server
- Continue until job completes

**Progress message format**:
```javascript
POST /daebug?name=<realm-name>&url=<realm-url>
{
  type: 'job-progress',
  jobId: string,
  backgroundEvents: Array<{...}>,
  elapsed: number  // ms since job start
}
```

**Server behavior**:
- Locate executing region in chat log (between executing-announcement header and placeholder)
- Replace background text section with newly formatted events
- Update placeholder elapsed time if threshold passed (e.g., 5s intervals)
- Do not write final reply or move footer; job still executing

**Visual effect**: The chat log shows real-time updates during long-running jobs:

```
> **agent** to page-name at HH:MM:SS
```JS
setInterval(() => console.log('tick'), 1000);
```

> **page-name** to agent at HH:MM:SS
```JSON console.log
tick
```
```JSON console.log  
tick
```
```JSON console.log
tick
```
executing (3s)
```

As more ticks occur, additional console.log blocks appear above the placeholder. When job completes or times out, placeholder is replaced with final result and duration.

---

## Cross-Cutting Concerns

### Worker Realm Considerations

Web workers use `self` instead of `window`, and have different console/error handling contexts. The capture layer must adapt:

- Use `self.addEventListener('error', ...)` instead of `window.addEventListener`
- Console object is same API but lives at `self.console`
- No `window.onerror` assignment; only event listener approach works
- Stack traces may differ in format; normalize during serialization

**Shared implementation**: The core capture logic can be unified between page and worker with conditional global detection:

```javascript
const globalScope = typeof window !== 'undefined' ? window : self;
const consoleTarget = globalScope.console;
// etc.
```

### Performance Impact

**Capture overhead**: Monkeypatching console and registering error handlers is lightweight. Typical overhead < 1ms per event.

**Serialization cost**: Converting objects to strings can be expensive for large/complex structures. Mitigate by:
- Truncating very long strings (e.g., 1000 chars per message)
- Limiting recursion depth in object serialization (max 3 levels)
- Detecting circular references early and bailing out

**Transmission cost**: Sending background events on every REPL job adds payload size. Typical impact: +1-5KB per request. For high-frequency jobs (e.g., animation loops), this is negligible compared to network overhead.

**Memory overhead**: Background event buffer accumulates in memory. With 50-event cap and ~200 bytes per event, maximum footprint is ~10KB per realm. Acceptable for debugging context.

### Security and Sandboxing

**Console output risks**: Console methods are often used to log sensitive data (auth tokens, user PII, etc.). Background capture exposes this to the REPL log.

**Mitigation strategies**:
- **User awareness**: Document that console output is captured and visible in logs
- **Opt-out mechanism**: Provide flag to disable console capture if sensitive (e.g., `window.__DAEBUG_NO_CONSOLE_CAPTURE = true`)
- **Redaction**: Future enhancement could scan for patterns (e.g., "token:", "password:") and redact values

**Error stack traces**: May reveal source code structure and internal implementation details. Less sensitive than console data but still consider in secure environments.

**Untrusted code**: If REPL is used to execute untrusted/adversarial code, background capture itself can be attacked:
- Malicious code could spam console.log to flood buffer and logs
- Tight loops throwing errors could overwhelm capture system
- Monkeypatching detection: adversarial code could detect and disable capture

**Defense**: Rate-limit background events (e.g., max 100 events/second). Drop excess events with warning message.

### Testability

Background event capture spans client and server, making testing complex.

**Unit tests** (per component):
- Console monkeypatch: verify original method called, arguments captured correctly
- Error handler: verify event normalization, stack extraction
- Buffer management: verify truncation, reset, memory bounds
- Markdown formatter: verify fence metadata, block structure
- Protocol: verify payload shape, backward compatibility

**Integration tests** (end-to-end):
- Trigger background error in live browser page REPL, verify appears in chat log
- Call console.log during REPL execution, verify output captured with correct fence metadata
- Execute long-running job, verify real-time updates appear incrementally
- Test both page and worker realms for each event type
- Verify background-only flush when no active job

**Reference implementation** in [test-runner.js](../js/test-runner.js) should include background capture tests to demonstrate correct behavior.

---

## Implementation Phases

### Phase 1: Client-Side Capture Foundation

**Goal**: Establish event capture in browser main thread (page realm only).

**Components**:
- Error handler registration for `window.onerror` and `unhandledrejection`
- Console monkeypatch wrapper for log/info/warn/error methods
- Background event buffer with structured event storage
- Event serialization utilities (objectâ†’string, stack extraction, timestamp formatting)

**Validation**: Add debugging console output to show captured events locally. Verify capture works but events not yet transmitted.

### Phase 2: Protocol and Transmission

**Goal**: Send background events to server with REPL results.

**Components**:
- Extend result payload with `backgroundEvents` structured array
- Include accumulated events with each REPL job result
- Clear job-specific events after transmission

**Validation**: Check server receives `backgroundEvents` in payload. Log to console on server side. Not yet formatted to Markdown.

### Phase 3: Server-Side Formatting

**Goal**: Convert structured events to Markdown and insert in chat logs.

**Components**:
- Eventâ†’Markdown translator with fence metadata logic
- Writer component updates to place background blocks after result blocks
- Truncation logic for 10+ events
- Integration with existing reply formatting flow

**Validation**: Execute REPL commands that trigger background events. Verify chat log shows formatted blocks with correct fence types.

### Phase 4: Worker Realm Support

**Goal**: Extend capture to web workers.

**Components**:
- Adapt capture layer for `self` global context
- Test worker-specific error handling differences
- Ensure worker results include background events

**Validation**: Trigger errors and console output in worker realm. Verify appear in worker's chat log with same formatting as page realm.

### Phase 5: Real-Time Streaming

**Goal**: Show background events during long-running jobs.

**Components**:
- Client-side periodic progress messages while job active
- Server-side executing-region text replacement
- Debouncing and update cadence control

**Validation**: Execute long-running job (e.g., 10-second loop with console.log every second). Verify log updates in real-time showing incremental events.

### Phase 6: Background-Only Flush

**Goal**: Capture events that occur outside REPL jobs.

**Components**:
- Client-side background event threshold detection
- Dedicated background-flush message type
- Server-side background-only header and placement
- Periodic flush timer

**Validation**: Execute REPL command that sets a timer for 10 seconds later. Return immediately. After timer fires and logs to console, verify background-only update appears in chat log.

### Phase 7: Polish and Optimization

**Goal**: Production readiness.

**Components**:
- Performance profiling and optimization (serialization cost, transmission size)
- Memory leak testing (long-running pages, buffer bounds)
- Error handling for capture failures (e.g., monkeypatch rejected by frozen console)
- Documentation and examples
- Security review (redaction, rate limits)

**Validation**: Load test with high-frequency events. Verify stable memory usage, no performance degradation. Test in multiple browsers.

---

## Success Criteria

Background event capture is complete when:

1. **Unhandled errors are visible**: Trigger `setTimeout(() => { throw new Error(...) })` in REPL, see error appear in log with `Error window.onerror` fence
2. **Console output is visible**: Call `console.log(...)` / `console.warn(...)` in REPL, see output appear with appropriate fence metadata
3. **Both page and worker supported**: Above tests pass in both page realm and worker realm chat logs
4. **Real-time updates work**: Long-running job shows incremental background events during execution, not just after completion
5. **Background-only flush works**: Events outside REPL job windows appear in log with background header
6. **Truncation functions**: Triggering 15+ background events shows first 2, ellipsis with count, last 8
7. **No false positives**: REPL evaluation errors don't duplicate in background events; only true background activity captured
8. **Performance acceptable**: No observable slowdown in REPL responsiveness; memory usage bounded

When these criteria are met, agents can observe complete runtime context and debug asynchronous/background behavior with confidence.
